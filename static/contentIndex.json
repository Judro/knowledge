{"Hot-List":{"title":"Hot List","links":[],"tags":[],"content":"\n Deep-learing (Di)\n Codeforce (Fr)\n Aufräumen\n linux x86 machine bereitstellen\n[ ]\n"},"TODO":{"title":"TODO","links":["rechnerarchitektur/assembly/x86-examples"],"tags":[],"content":"\nfix the numbers function call using stack frames\n"},"index":{"title":"index","links":["rechnerarchitektur/CPU","rechnerarchitektur/assembly/x86","rechnerarchitektur/c~lang/Array-vs.-Pointer"],"tags":[],"content":"CPU | x86 | Array vs. Pointer"},"other/The-XY-problem":{"title":"The XY problem","links":[],"tags":[],"content":"\nis asking about your attempted solution rather than your actual problem\nThe problem occurs when people get stuck on what they believe is the solution and are unable step back and explain the issue in full.\n\n"},"playground":{"title":"playground","links":["assets/iris-autoencoder.py"],"tags":[],"content":"import numpy as np\nimport torch\nimport torch.nn as nn\nfrom torch.utils.data import TensorDataset, DataLoader\nfrom sklearn.datasets import load_iris\nfrom sklearn.decomposition import PCA\nimport matplotlib.pyplot as plt\n \nclass AutoEncoder(torch.nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.encoder = torch.nn.Sequential(\n            torch.nn.Linear(4, 2),\n            torch.nn.ReLU(), # &lt;-- Funktion variieren\n            )\n        self.decoder = torch.nn.Sequential(\n            torch.nn.Linear(2, 4),\n            torch.nn.ReLU(), # &lt;-- Funktion variieren\n            )\n \n    def forward(self, x):\n        encoded = self.encoder(x)\n        decoded = self.decoder(encoded)\n        return decoded\n \n    \ndef main():\n    # === Daten laden ===\n    X, y = load_iris(return_X_y=True)\n    #X = PCA(4).fit_transform(X) # &lt;-- ein/aus kommentieren\n    train = TensorDataset(torch.as_tensor(X, dtype=torch.float32))\n    train_loader = DataLoader(train,\n                              batch_size=16,  # &lt;-- Zahl variieren\n                              shuffle=True)\n \n    \n    # === Modell trainieren ===    \n    model = AutoEncoder()\n    loss_fun = nn.MSELoss()\n    optimizer = torch.optim.SGD(model.parameters(),\n                                lr = 0.004)  # &lt;-- Zahl variieren\n    print(&quot;initial encoder weights\\n&quot;, model.encoder[0].weight.detach().numpy())\n \n    epochs=20 # &lt;-- Zahl variieren\n    losses=[]\n    for epoch in range(epochs):\n        for sample in train_loader:\n            reconstructed = model(sample[0])\n            loss = loss_fun(reconstructed, sample[0])\n            # recompute gradients:\n            optimizer.zero_grad() # clean gradient cache\n            loss.backward() # do backprop\n            optimizer.step() # use gradient to learn\n            losses.append(loss.detach().numpy())\n \n \n    # === Ergebnisse angucken ===\n    print(&quot;found encoder weights\\n&quot;, model.encoder[0].weight.detach().numpy())\n            \n    # geht das in den folgenden zwei Zeilen nicht auch schöner?\n    reconstruction = np.array([model(torch.tensor(x, dtype=torch.float32)).detach().numpy() for x in X])\n    latents = np.array([model.encoder(torch.tensor(x, dtype=torch.float32)).detach().numpy() for x in X])\n \n    # plot in X-PCA coordinates:\n    pca = PCA(2).fit(X)\n    X = pca.transform(X)\n    reconstruction_ = pca.transform(reconstruction)\n    reconstruction = PCA(2).fit_transform(reconstruction)\n    \n    fig, (ax1, ax2, ax3, ax4, ax5) = plt.subplots(5)\n    ax1.scatter(X[:, 0], X[:, 1], c=y)\n    ax1.set_title(&quot;Original data, first two PCs&quot;)\n    ax2.scatter(reconstruction_[:, 0], reconstruction_[:, 1], c=y)\n    ax2.set_title(&quot;Reconstruction, same projection &quot;)\n    ax3.scatter(reconstruction[:, 0], reconstruction[:, 1], c=y)\n    ax3.set_title(&quot;Reconstruction, first two PCs&quot;)\n    ax4.scatter(latents[:, 0], latents[:, 1], c=y) #XXX\n#    ax4.scatter(latents[:, 0], np.zeros_like(latents[:,0]), c=y)\n    ax4.set_title(&quot;Latent vectors&quot;)\n    ax5.plot(losses)\n    ax5.set_title(&quot;MSE Loss&quot;)\n    plt.subplots_adjust(hspace=0.5)\n    plt.show()\n    \nif(__name__ == &quot;__main__&quot;):\n    main()\n \nTransclude of iris-autoencoder.py\nf x = x * 3 \nmain = do\n  print (f(3))"},"rechnerarchitektur/CPU":{"title":"CPU","links":["rechnerarchitektur/CPU/x86","rechnerarchitektur/assembly/x86","rechnerarchitektur/CPU","rechnerarchitektur/CPU/SIMD","rechnerarchitektur/CPU/MISD","rechnerarchitektur/CPU/MIMD","tags/rechnerarchitektur"],"tags":["rechnerarchitektur"],"content":"x86 architecture | x86 assembly\nVon Neumann machine\n\n\nstrictly sequential processing\n\neasy to program\n\n\ninstruction and data are stored in the main memory\n\ncompete access to the memory  \\Rightarrow Possible bottleneck!\n\n\n\n![[vonneumanncpu.png|300]]\nPerformance improvements?\n\nComman techniques\n\nIncrease the clock frequency\nIncreasing the cache size\nIncreasing the number of pipeline stages\n\n\nChallenges\n\nThere are often situation points for these techniques, which limit performance gains.\nAnd with increasingly complex architectures, not only the monetary cost for these techniques increase disproportionately.\n\n\n\nPipelining\n\n= Concurrent execution of phases of an instruction\nExample: 4-stage pipeline;\n\nOnly throughput is increased\nProblem: conditional jumps\n\\rightarrow branch prediction\n![[pipelining4stage.png|250]]\n\n\n\nExtensions of the von Neumann Machine\n\nFlynn defined four classifications for modern computer architectures Based on the number of concurrent instruction streams and data streams available\n\nSISD: Single Instruction Single Data \\Rightarrow von Neumann Machine\nSIMD: Single Instruction Multiple Data\nMISD: Multiple Instruction Single Data\nMIMD: Multiple Instruction Multiple Data\n\n\nKnows as Flynn’s taxonomy\n\nChip-Level Multi-processing\n\nReduction of 1% voltage and 1% frequency reduces the power consumption by 3% and the performance by 0.66%$\n\n\nSimultaneous Multithreading / Hyperthreading\n\nProcessors are mostly waiting for the main memory or the I/O devices\nIdea: Hardware emulates a second logical core\n\nIf the core has nothing to do, it is able to switch to another instruction stream\n\n\n\n\nAssembly\n\nx86\nError-prone!\nwhy?:\n\ncontext switch, interrupt handling, usage of special I/O instructions\n\n\n\nrechnerarchitektur"},"rechnerarchitektur/CPU/MIMD":{"title":"MIMD","links":[],"tags":[],"content":"MIMD: Multiple Instruction Multiple Data\n\nMultiple instructions \\Rightarrow multiple CPUs, which are able to compute multiple instruction streams\nIn principle, two design options:\n\nCPUs doesn’t share the memory \\Rightarrow also known as cluster\nCPUs share the memory \\Rightarrow multi-processor systems\n\n\n"},"rechnerarchitektur/CPU/MISD":{"title":"MISD","links":[],"tags":[],"content":"MISD: Multiple Instruction Single Data\n\nSeveral CPUs process one data stream executing different instructions\nMainly for fault tolerance, e.g. flight computer in space shuttle\n"},"rechnerarchitektur/CPU/SIMD":{"title":"SIMD","links":[],"tags":[],"content":"SIMD: Single Instruction Multiple Data\n\nIn principle, one instruction on a set of data \\Rightarrow e.g. vector operations\n\n\n"},"rechnerarchitektur/CPU/x86":{"title":"x86","links":[],"tags":[],"content":"Registers\n\nonly integers\n16 general registers (64 bit)\n\nRAX RBX RCX RDX RDI RSI RSP RBP\nR8 R9 R10 R11 R12 R13 R14 R15\n\n\nstatus registert (RFLAGS) (64 bit)\ninstruction pointer (RIP)(64 bit)\nimplicitly assigned registers:\n\nRSP: stack pointer\nRBP: base register\nRCX: count register\nRSI, RDI: (source / destination) index register\n\n\n\n"},"rechnerarchitektur/assembly/c-calling-convention":{"title":"c calling convention","links":["rechnerarchitektur/assembly/x86","rechnerarchitektur/CPU/x86","rechnerarchitektur/CPU","rechnerarchitektur/assembly/x86-examples","tags/rechnerarchitektur","tags/c_lang"],"tags":["rechnerarchitektur","c_lang"],"content":"x86 assembly | x86 architecture | CPU | wiki calling_conventions\n\nPassing the first six arguments by register (System Call)\n\nAfterwards the stack is used (Right-To-Left (RTL) order)\n\n\nthe function who polluted the stack has to clean it!\n\nExample from “hello world” to function call\n\nHello World using  int 0x80\ncall and ret using syscall\nusing stackframe\n\nnumber doesn’t fit (of addition todo)\nAdd Stackframe visualization\n\n\n\n\nin x86 (32bit) is stack used for arguments\nother conventions\n\nrechnerarchitekturc_lang"},"rechnerarchitektur/assembly/x86-examples":{"title":"x86 examples","links":["rechnerarchitektur/CPU","rechnerarchitektur/assembly/x86","rechnerarchitektur/CPU/x86"],"tags":[],"content":"CPU |  x86 | x86\nfirst minimal\nSECTION .text\n \n; the destination of an instruction is always the left side\n \n;load 42 into the register rax\nmov rax, 42\n \n; load 0 into the register rax\nmov rbx, 0\n \n; addition of op1 and op2, result is stored in op1 (left side) =&gt; e.g. rax = rax + rbx\nadd rax, rbx\n \n; subtraction of op1 and op2, result is stored in op1 (left side) =&gt; e.g. rax = rax - rbx\nsub rax, rbx\n \n; unsigned multiply, rdx:rax = rax * op\nmul rbx\n \n; signed multiply, rdx:rax = rax * op =&gt; e.g. rdx:rax = rax * rbx\nimul rbx\nHello Wold\nSECTION .data\n\tmsg: db &quot;Hello World&quot;,10 ; the string to print, 10=cr\n\tlen: equ 12 ; similar to #define in C\n \nSECTION .text ; code section\n \nglobal _start ; make label available to linker\n \n_start: ; standard entry point\n\tmov rdx, len ; arg3, length of string to print\n\tmov rcx, msg ; arg2, pointer to string\n\tmov rbx, 1 ; arg1, file descriptor (stdout)\n\tmov rax, 4 ; sys_write syscall number\n\tint 0x80 ; fire system call\n\tmov rbx, 0 ; exit code, 0=normal\n\tmov rax, 1 ; exit command to kernel\n\tint 0x80 ; interrupt 80 hex, call kernel to exit process\nfunction call using x86_64 ABI\nSECTION .text       ; code section\n \nglobal _start       ; make label available to linker\n_start:             ; standard entry point\n\tmov rdi, 1      ; arg1, file descriptor (stdout)\n\tmov rsi, msg    ; arg2, pointer to string\n\tmov rdx, len    ; arg3, length of string to print\n\tcall _my_func   ; push raddr on stack and jump to label my_func\n\tmov rbx, 0      ; exit code, 0=normal\n\tmov rax, 1      ; exit command to kernel\n\tint 0x80        ; interrupt 80 hex, call kernel to exit process\n \n_my_func:           ; our function\n\tmov rbx, rdi    ; arg1, file descriptor (stdout)\n\tmov rcx, rsi    ; arg2, pointer to string\n; mov rdx, rdx      ; arg3, length of string to print\n \n\tmov rax, 4      ; sys_write syscall number\n\tint 0x80        ; fire system call\n\tret\nfunction call using syscall instruction\nSECTION .text      ; code section\n \nglobal _start      ; make label available to linker\n_start:            ; standard entry point\n\tmov rdi, 1     ; arg1, file descriptor (stdout)\n\tmov rsi, msg   ; arg2, pointer to string\n\tmov rdx, len   ; arg3, length of string to print\n\tcall _my_func  ; push raddr on stack and jump to label my_func\n \n\tmov rbx, 0     ; exit code, 0=normal\n\tmov rax, 1     ; exit command to kernel\n\tint 0x80       ; interrupt 80 hex, call kernel to exit process\n \n_my_func:          ; our function\n\tmov rax, 1     ; sys_write syscall number = 1 =&gt; 64 bit interface\nsyscall            ; fast system call =&gt; faster than int 0x80\nret\nfunction call using stack frames\nSECTION .text       ; code section\n \nglobal _start       ; make label available to linker\n_start:             ; standard entry point\n\tpush 1          ; arg1, file descriptor (stdout)\n\tpush msg        ; arg2, pointer to string\n\tpush len        ; arg3, length of string to print\n\tcall _my_func   ; push raddr on stack and jump to label my_func\n \n\tmov rbx, 0      ; exit code, 0=normal\n\tmov rax, 1      ; exit command to kernel\n\tint 0x80        ; interrupt 80 hex, call kernel to **exit** process\n\t\n_my_func:                  ; our function\n\tpush rbp               ; save stack frame pointer\n\tmov rsp, rbp           ; set rsp to new stackframe\n\tmov rbx, [rbp + 32]    ; arg1, file descriptor (stdout)\n\tmov rcx, [rbp + 24]    ; arg2, pointer to string\n\tmov rdx, [rbp + 32]    ; arg3, length of string to print\n\tmov rax, 4             ; sys_write syscall number\n\tint 0x80         ; fire system call\n\t\n\tpop rbp          ; save stack frame pointer\n\tret 24           ; remove params and return by popping return addres\n\nThis is not used in x86_64 but was used in IA32 (32 Bit protected mode)\n\nfor-Loop\n\nfor (int i=0; i&lt;10; i++);\n\n\txor rcx, rcx  ; set counter = 0\n \nL0:\n\tcmp rcx, 10    ; compare counter with 10\n\tjge L1.        ; leave loop if rcx &gt;=10\n \n\t...            ; loop body\n \n\tinc rcx        ; rcx++\n\tjmp L0.        ;jump back for next iteration\n \nL1:\nloop\n\nusing loop instruction\n\n\tmov rcx, 10   ; set counter = 10\nL0:               \n                  \n\t...           ; loop body\n\tloop L0       ; jump back for next iteration\n \nL1:"},"rechnerarchitektur/assembly/x86":{"title":"x86","links":["rechnerarchitektur/CPU","rechnerarchitektur/assembly/x86","rechnerarchitektur/assembly/c-calling-convention","rechnerarchitektur/assembly/x86-examples","tags/rechnerarchitektur"],"tags":["rechnerarchitektur"],"content":"Sections\n\nseparation of code and data is not needed (von-Neumann)\ncreating of section for the respective logical areas\n\nSECTION .data\n; global data\nSECTION .bss\n; uninitialized global data\nSECTION .text\n; provides code\nData Types\n\nThe base is a word (16 bit).\n\nSECTION .data\n\tMyByte DB 0 ; Define one byte (8 bit)\n\tMyWord DW 0 ; Define one word (16 bit)\n\tMyDword DD 0 ; Define one double word (32 bit)\n\tMyQword DQ 0 ; Define one quad word (64 bit)\nHow are the data types located in memory\n\nLittle vs Big Endian\nLittle Endian: The leas significant byte first \\Rightarrow used in x86 architecture\n\n“Unintuitiv — Andersrum als erwartet”\nExample DEADBEEF\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdress [Byte]0123Little EndianE FB EA DD EBig EndianD EA DB EE F\nArrays and strings\n\nA string is an array of bytes (0 terminated)\n\nSECTION .data\n\tStr DB &quot;I am a string!&quot;, 13, 10, 0\n\tCharacter DB &quot;A&quot;\nuninitialized arrrays\n\nin BSS section\n\nin principle, (uninitialized) array con be defined in every section\n\n\n\nSECTION .data\n\tarray TIMES 1024 DB 0; initialized array\nSECTION .bss\n\tvar RESB 1 ;1 element of type &quot;Byte\n\tarray2 RESB 2048 ; 2048 elements of type &quot;Byte&quot;\n\tfeld RESD 1024 ;1024 elements of type &quot;Doubleword&quot;```\nImport / export of symbols\n\nSymbol is a marker / an address within the data / code section\ncan be defined in one file and used by another file\n\n;define that printf is defined in another module\nextern printf\n;define errno as symbol, which can be used by another module\nglobal errno\n \nSECTION .data\n\terrno DW 0\nFunction call — Hello World\n\nRegister mapping for system calls using int 0x80\n\nDeveloped for 32 (but in 64 bit long mode)\nregister mapping for system call invocation using int 0x80:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsystem call number1st parameter2nd parameter3rd paramter4th5th6thresulteaxebxecxedxesiediebpeax![[x86 examples#hello-woldHello Wold]]\nnasm -f elf64 hello.asm\nld -m elf_x86_64 hello.o –o hello\n./hello\nStack\n; store data from rdx on the stack\npush rdx\n \n;do something\n \n;restore data\npop rdx\nMemory layout\n\nRSP points always to the top of the stack\nThe stack grows from the high address to the low address\nThe heap grow from low address to high address\n\nFunction call — using syscall\n\ndifferent to function call using 0x80 (register mapping)\nsyscall uses x86_64 ABI, so all parameters are already in the right registers\nRegister mapping using syscall\nc calling convention\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsystem call number1st parameter2nd parameter3rd parameter4th parameter5th6thresultraxrdirsirdxr10r8r9rax\n\nTransclude of x86-examples#function-call-using-syscall-instruction\nSee wiki assembly interface\n\nRFLAGS Register\n\nCF, ZF are used for unsigned conditional jump\nSF, OF, ZF are used for signed conditional jump\n\n\nJumps\nUnsigned conditional jumps\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncmp a, bMnemonicFlagsDescriptiona-b&gt;0JA / JNBECF=0 and ZF=0above / not below nor equala-b\\ge0JAE / JNBCF=0above or equal / not belowa-b&lt;0JB / JNAECF=1below / not above  nor equala-b\\le0JBE / JNACF=1 or ZF=1below or equal / not above\ntarget: ...\n\tsub rax, 1\n\tcmp rax, 1\n\tjae target\nSigned conditional jump\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncmp a, bMnemonicFlagsDescriptiona-b&gt;0JG / JNLE((SF xor OF) or ZF) = 0greater / not less nor equala-b &gt;=0JGE / JNL(SF xor OF) = 0greater or equal / not lessa-b&lt;0JL / JNGE(SF xor OF) = 1less / not greater or equala-b\\le0JLE / JNG((SF xor OF) or ZF) = 1less or equal / not greater\ntarget: ...\n\tsub rax, 1\n\tcmp rax, 1\n\tjge target\nLoop\n\nexample without loop instruction\nloop decrements rcx, checks for 0 if rcx is 0, terminates the loop\n\notherwise continues\nTransclude of x86-examples#loop\n\n\n\nrechnerarchitektur"},"rechnerarchitektur/c~lang/Array-vs.-Pointer":{"title":"Array vs. Pointer","links":["rechnerarchitektur/c~lang/Pointer-Arithmetik","tags/c_lang","tags/pointer"],"tags":["c_lang","pointer"],"content":"Pointer-Arithmetik\n\nArray \\ne Pointer\nArray speichert Daten\nPointer speichert eine Adresse von Daten\nEin Zeiger muss nicht auf den Anfang eines Arrays zeigen,\n\nein Array-Name tut dies immer\n\n\na[i] = *(a +i)\narray[] kann nicht einem Zeiger zugewiesen werden\nchar *ptr ist konstant und darf somit nicht geändert werden\n\nchar arr[] schon\n\n\n\nArray als Argument Funktion übergeben\n/* arrptr_size.c */\n#include &lt;stdio.h&gt;\n \nvoid foo(int array[]) {\n\tint entries = sizeof(array) / sizeof(int);\n\tprintf(&quot;sizeof(array)=%lu, entries=%d\\n&quot;, sizeof(array), entries);\n}\n \nint main(void) {\n\tint array[] = {1, 2, 3, 4, 5};\n\tint entries = sizeof(array) / sizeof(int);\n\tprintf(&quot;sizeof(array)=%lu, entries=%d\\n&quot;, sizeof(array), entries);\n\tfoo(array);\n\treturn 0;\n}\n\nGröße geht verloren\n\nExtern\n\nwenn array in anderer Datei definiert, darf auch nur über extern $(Typ) array[] darauf zugegriffen werden:\n\n/* file1.c */\n#define BUFFER_SIZE 10000\nchar buff[BUFFER_SIZE];\n/* file2.c */\n#include&lt;stdio.h&gt;\n \nextern char buff[];\n \nint main (void) {\n\tbuff[0] = &#039;A&#039;;\n\tbuff[1] = &#039;\\0&#039;;\n\tputs(buff);\n\treturn 0;\n}\ngcc -m32 -o test file1.c file2.c -g\ngdb test -tui\n\nstop extern char *buff;\n\nder Zugriff über Pointer hat eine Indirektion mehr\nEs werden nun die ersten 4 Byte (32 Bit) unseeres char-Arrays ausgelesen  und als Pointer verwendet und der Wert dann dereferenziert\n\nDa hier kein Pointer: Programm stürzt ab\n![[arrayvspointer.png|600]]\n\n\n\n\n\nchar array[100] = &quot;don&#039;t&quot;;\nchar *ptr       = &quot;panic&quot;; \n![[cptr.png|100]]![[carray.png|100]]\nc_langpointer"},"rechnerarchitektur/c~lang/Pointer-Arithmetik":{"title":"Pointer-Arithmetik","links":["rechnerarchitektur/c~lang/Array-vs.-Pointer","tags/rechnerarchitektur","tags/c_lang","tags/pointer"],"tags":["rechnerarchitektur","c_lang","pointer"],"content":"Array vs. Pointer\n\nZeiger können zur Laufzeit verändert werden\n\nWert*Typ\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAusdruckZeiger-TypAddierter Wert auf die Adresseptr+1char1ptr+1int32_t4ptr+1double8\n/* ptr_arith.c */\n#include &lt;stdio.h&gt;\n \nint main(void) {\n\tint array[] = {45, 67, 89};\n\tint *array_ptr = array; \n \n\tprintf(&quot;first element: %d\\n&quot;, *(array_ptr++));\n\tprintf(&quot;second element: %d\\n&quot;, *(array_ptr++));\n\tprintf(&quot;third element: %d\\n&quot;, *(array_ptr));\n}\n \n\nAchtung array_ptr++inkrementiert erst nachdem der Wert geladen ist.\n\nrechnerarchitektur c_langpointer"},"rechnerarchitektur/c~lang/linked-list":{"title":"linked list","links":["rechnerarchitektur/c~lang/Pointer-Arithmetik","rechnerarchitektur/c~lang/Array-vs.-Pointer","tags/pointer","tags/c_lang"],"tags":["pointer","c_lang"],"content":"Pointer-Arithmetik  | Array vs. Pointer\n\nsollte vielleicht nicht in production verwendet werden, dient nur als Beispiel für die Nutzung vonpointer und Pointer-Arithmetik 😅\n\n/* list.c */\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\ntypedef struct ListElement {\n\tstruct ListElement* next;\n\tvoid* data;\n}ListElement;\n \ntypedef struct List{\n\tListElement* head;\n\tsize_t t_size;\n}List;\n \nvoid l_init(List* list, size_t t_size){\n\tlist-&gt;head=NULL;\n\tlist-&gt;t_size=t_size;\n}\n \nvoid l_append(List* list, void* data) {\n\tvoid* new_data = malloc(list-&gt;t_size);\n\tmemcpy(new_data,data,list-&gt;t_size);\n\tListElement* e = malloc(sizeof(struct ListElement));\n\te-&gt;next = NULL;\n\te-&gt;data=new_data;\n\tif(list-&gt;head == NULL){\n\t\tlist-&gt;head=e;\n\t\treturn;\n\t}\n\tListElement* tmp = list-&gt;head;\n\twhile (tmp-&gt;next != NULL) {\n\t\ttmp = tmp-&gt;next;\t\n\t} \n\ttmp-&gt;next=e;\n}\n \nvoid l_insert(List* list, void* data, unsigned position){\n\t// if index is longer than the list it will append the end of it\n\tvoid* new_data = malloc(list-&gt;t_size);\n\tmemcpy(new_data,data,list-&gt;t_size);\n\tListElement* e = malloc(sizeof(struct ListElement));\n\te-&gt;next = NULL;\n\te-&gt;data=new_data;\n\tif(list-&gt;head == NULL){\n\t\tlist-&gt;head=e;\n\t\treturn;\n\t}\n\tif (position==0){\n\t\te-&gt;next=list-&gt;head;\n\t\tlist-&gt;head=e;\n\t\treturn;\n\t}\n\tListElement* next = list-&gt;head;\n\tunsigned i = 0;\n\twhile (i+1&lt;position&amp;&amp;next-&gt;next!=NULL){\n\t\tnext=next-&gt;next;\n\t\ti++;\n\t}\n\te-&gt;next=next-&gt;next;\n\tnext-&gt;next=e;\n}\n \nvoid l_delete(List* list, unsigned index) {\n\t\n}\n \n/* main.c */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n \nvoid print_int_list(List* list){\n\tListElement* next = list-&gt;head;\n\twhile (next != NULL) {\n\t\tprintf(&quot;%d&quot;, *(int*)next-&gt;data);\n\t\tnext=next-&gt;next;\n\t}\n}\n \nint main(void) {\n\tint inputs[] = {1,2,3,4,5};\n\tList list;\n\tl_init(&amp;list,sizeof(int));\n\tl_append(&amp;list,inputs);\n\tl_append(&amp;list,inputs+2);  \n\tl_append(&amp;list,inputs+4);\n\tl_insert(&amp;list,inputs+1,1);\n\tl_insert(&amp;list,inputs+3,3);\n\tl_insert(&amp;list,inputs,10);\n\tl_insert(&amp;list,inputs+4,0);\n\tprint_int_list(&amp;list);\n\tprintf(&quot;\\nshould be 5123451\\n&quot;);\n\treturn 0;\n}\nc_lang"}}